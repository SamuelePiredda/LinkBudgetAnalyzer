"""

    Author:     Samuele Piredda
    Date:       05/11/2025
    Version:    1.0

    Software used for analyzing the access time with ground stations

    It uses 4 files to analyze the ground stations access:

    1) Sat.txt which contains all parameters used by the satellite for the link budget.
        The following list is how the file must be, change only the values at the right side of the =
        [do not include the section -> |....., include only the values and then the new line]

        Satellite Gain [dBi] = 5                    | gain of the satellite antenna in dBi
        Transmitting Power [W] = 1                  | transmitting power of the satellite in Watts
        Satellite Cable loss [dBi] = 1              | signal loss between the radio and the antenna in dB
        Pointing Error [dBi] = 1                    | antenna pointing error of the satellite to the ground station in dB
        Data rate [bps] = 76800                     | data rate of the transmission in bit per second
        Frequency [GHz] = 2.2                       | frequency of the link in GHz
        Noise temperature [K] = 300                 | noise temperature of the receiver in kelvin
        RX Loss [dB] = 1                            | overall losses of the receiver in dB
        Extra losses [dB] = 2                       | extra losses in dB
        EbN0 minimum [dB] = 15                      | the minimum EbN0 to achieve the deisred BER in dB
        Margin [dB] = 3                             | the margin of the link in dB
        Data coefficient [≤1] = 1                   | the data rate coefficient which discriminate between information and data rate
        Probability = 0.01                          | the probability used for the atmospheric losses
        Time link opening [s]= 10                   | time needed to create the link (if the access time is smaller the pass is discarded)


    2) GS.txt contains all the informations about the ground stations.
        Each line is composed by six information separated by ;
            1) name of the ground station
            2) gain of the ground station antenna
            3) diameter of the ground station antenna (used for the atmospheric losses)
            4) latitude of the GS in deg (between -90 and +90)
            5) longitude of the GS in deg (between 0 and 360)
            6) minimum elevation of the GS in deg (must be > 5 otherwise the itur library will get mad)

        IT-01;32;5;45.32;9.74;10
        USA-01;32;5;31.9;257.2;10
        AU-01;32;5;-29.68;131.2;10
        UAE-01;32;5;25.29;51.07;10
        CHL-01;32;5;-52.99;290.37;10
        SK-01;32;5;36.35;128.1;10


    3) PosSat.txt is generated by GMAT and it contains the position, altitude and time of the satellite during the orbit
        propagation. The file has no headers and each value is separated by a \t

        The date time are like this: 01 Jan 2026 12:00:04.034
                                     "%d %b %Y %H:%M:%S.%f"
                                     A1Gregorian (in GMAT)

        The file is composed as follows:

        X position[km]      Y position[km]      Z position[km]      altitude[km]        date time[A1Gregorian]
        
        This is an example of the file

        1828.618113594886      -3704.997481522823     5561.144977119564      563.6864634068752      01 Jan 2026 12:00:00.034
        1820.341631101501      -3695.829789996597     5569.953572606118      563.730042467243       01 Jan 2026 12:00:02.034
        1812.056446574801      -3686.644431925168     5578.735469080988      563.7735986715606      01 Jan 2026 12:00:04.034
        1803.762599742965      -3677.441451464411     5587.49062482443       563.8171312821823      01 Jan 2026 12:00:06.034
        1795.460130374445      -3668.220892853159     5596.218998245997      563.8606395624402      01 Jan 2026 12:00:08.034
        ........


    4) PosGS.txt is generated by GMAT at the same time of the previous one. It is important that the two files are generated
        with the same time steps in order to have less errors. This file contains the position of each ground station
        in each time step.

        WARNING: the amount of ground station in this file must be the same of the GS.txt one

        Each value is separated by \t and it is composed as follows:

        GS1 position X      GS1 position Y      GS1 position Z      GS2 position X      GS2 position Y      GS2 position Z .......

        This is an example with six ground stations so we have 18 different values (position are expressed in km):

        1575.268186475683      -4203.231019707983     4531.365956781675      -5402.528570759724     201.7033114904008      3384.172495254401      3413.739675271468      4358.575795620435      -3166.989283955164     5086.207832216581      -2730.672791421879     2711.925267234453      -3302.625789400014     -1979.668239910193     -5084.702470790056     3395.555328299215      3863.312783708567      3771.689410472508      
        1575.881197707005      -4203.002911807226     4531.364394163332      -5402.557914387719     200.9141423136577      3384.172594665153      3413.103961543302      4359.074787290767      -3166.987686727099     5086.606037061346      -2729.931983991211     2711.924233434736      -3302.337059398475     -1980.147998313563     -5084.70318821816      3394.991877024434      3863.806560971072      3771.690824512621      
        1576.494175567848      -4202.774714541482     4531.36283162683       -5402.587142916935     200.1249689896923      3384.172693783995      3412.468175147909      4359.573686163189      -3166.986089311714     5087.004133798632      -2729.191118609481     2711.923199907487      -3302.048259476528     -1980.6277145273       -5084.703905825008     3394.428353830783      3864.300255975489      3771.69223873782       
        ......



    The files are not loaded in the RAM but each line is loaded and analyzed in order to process large amount of data.
    It will take more time but you need as little RAM as possible.

    The final results are saved in the output.csv file


"""

print("Loading librieries...")

import itur
import math
from dataclasses import dataclass, field
from datetime import datetime
import time
import pickle
import pandas as pd
import os
import numpy as np


# setting up pandas display option to see all the columns and rows 
pd.set_option('display.width', 0)
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows',None)
pd.set_option('display.expand_frame_repr', False)








# ------------------------------------- DATA STRUCT SECTION -------------------------------------






# struct that contains the position vector X,Y,Z for satellite and ground stations
@dataclass
class Vector_struct:
    X:float = 0
    Y:float = 0
    Z:float = 0

# struct that contains all the information regrding the satellite
@dataclass
class SAT_struct:
    Gain:float = 0
    TX_power:float = 0
    TX_cable_loss:float = 0
    Pointing_error:float = 0
    Data_rate_log:float = 0         # this is data rate in log10
    Data_rate:float = 0             # this is data rate in bps
    Frequency:float = 0             # this is frequency in km
    Noise_temp:float = 0            # this is the temperature noise in dB
    RX_loss:float = 0
    Extra_loss:float = 0
    EbN0:float = 0
    Margin:float = 0
    Datarate_coeff:float = 0        # this is used to differentiate between information rate and data rate [<=1]
    Probability:float = 0           # probability used for the atmospheric losses (0.01 is a good value)
    Time_linkOpening:float = 0      # time to subtract for the opening of the link




# struct with all the ground stations data
@dataclass
class Ground_stations_struct:
    Names:list = field(default_factory=list)
    Diameters:list = field(default_factory=list)
    lats:list = field(default_factory=list)
    lons:list = field(default_factory=list)
    min_elevs:list = field(default_factory=list)
    gains:list = field(default_factory=list)

    Num:int = 0             # total number of ground stations

# struct with all the files name that we are going to use
@dataclass
class FILES_struct:
    Sat_file:str = "Sat.txt"
    GS_file:str = "GS.txt"
    PosSat_file:str = "PosSat.txt"
    PosGS_file:str = "PosGS.txt"
    Output_file:str = "Output.csv"

# struct with all the output information and the parameters used during the analysis
@dataclass
class Output_struct:
    Tot_analysis_time:float = 0                 # total analysis time in seconds                    
    Tot_access_time:float = 0                   # total access time to GS in seconds
    Min_link_margin:float = float("inf")        # global minimum link margin calculated
    AVG_link_margin:float = 0                   # global average link margin calculated
    Max_link_margin:float = float("-inf")       # global maximum link margin calculated
    Min_access_time:float = float("inf")        # global minimum access time to a GS
    Max_access_time:float = float("-inf")       # global maximum access time to a GS
    AVG_access_time:float = 0                   # global average access time to a GS
    Average_time_per_contact:float = 0          # gloabl average time per contact
    Average_time_per_day:float = 0              # global average time of contact per day
    Data_volume_total:float = 0                 # data volume download in total
    Data_volume_per_day:float = 0               # data volume downlink per day
    Tot_contacts:float = 0                      # total number of contacts

    GS_names:list = field(default_factory=list)         # list of names of GS
    GS_num_access:list = field(default_factory=list)    # list of access number for each GS
    GS_min_access:list = field(default_factory=list)    # list of minimum access time for each GS
    GS_max_access:list = field(default_factory=list)    # list of maximum access time for each GS
    GS_data_volume:list = field(default_factory=list)   # list of total data volume for each GS
    GS_min_lm:list = field(default_factory=list)        # list of minimum link margin recorded for each GS
    GS_max_lm:list = field(default_factory=list)        # list of maximum link margin recorded for each GS

    NoAccess_Step:list = field(default_factory=list)    # list of all the time that passes between two contacts
    Max_time_noAccess:float = 0                         # maximum time that passes between two access
    AVG_time_noAccess:float = 0                         # average time that passes between two access


# dataclass struct used to contain all the data used during the analysis
@dataclass
class Analysis_struct:    
    Elevation:float = 0             # elevation angle of the GS in order to communicate [deg]
    Distance:float = 0              # distance between satellite and ground station [km]
    Link_active:bool = False        # boolean if the link is active or not
    DateTime_A:datetime = None      # datetime A
    DateTime_B:datetime = None      # datetime B (used for datetime comparison)

    analysis_days:float = 0         # how many days of analysis in total

    Altitude:float = 0              # altitude of the satellite during the analysis
    Re:float = 0                    # radius of the Earth in the position of the satellite

    FSL:float = 0                   # free space loss container [dB]
    Atm_loss:float = 0              # atmospheric loss container [dB]

    Starting_time:float = 0         # starting time in seconds
    Ending_time:float = 0           # ending time in seconds to calculate how much time is passed for the analysis


# dataframe struct of an access
@dataclass
class DataFrameRow_struct:  
    GS_Name:str = ""                # name of the GS
    Start:str = ""                  # starting time 
    Stop:str = ""                   # stopping time
    Duration:float = 0              # link time of the passage
    Min_LM:float = float("inf")     # minimun link margin recorded for this passage   
    Max_LM:float = float("-inf")    # maximum link margin recorded for this passage
    Data:float = 0                  # data download in this passage
    

# dataframe which contains all the data for each DataFrameRow_struct
dataframe = pd.DataFrame({
    'GS Name': pd.Series(dtype='string'),
    'Start': str,
    'Stop': str,
    'Duration [sec]':pd.Series(dtype='float'),
    'Min L.M. [dB]':pd.Series(dtype='float'),
    'Max L.M. [dB]':pd.Series(dtype='float'),
    'Data [MB]':pd.Series(dtype='float')
    })







# ------------------------------------- FUNCTIONS SECTION --------------------------------------






# calculate the distance between two vectors struct
def calcDistance(P1:Vector_struct, P2:Vector_struct) -> float:
    return math.sqrt((P1.X-P2.X)*(P1.X-P2.X) + (P1.Y-P2.Y)*(P1.Y-P2.Y) + (P1.Z-P2.Z)*(P1.Z-P2.Z))

# calculate the free space loss
def FSL(distance:float, SAT:SAT_struct) -> float:
    return 20*math.log10(4*math.pi*distance*1e3*SAT.Frequency*1e9/3e8)

# calculate the atmospheric attenuation
def AtmosphericAttenuation(GS:Ground_stations_struct, SAT:SAT_struct, elev:float, index:int) -> float:
    try:
        if elev < 0 or elev > 90:
            print("Warning! Elevation is out of 0 <= elevation <= 90 range")
            elev = 10
        return itur.atmospheric_attenuation_slant_path(GS.lats[index], GS.lons[index], SAT.Frequency*itur.u.GHz, an.Elevation, SAT.Probability, GS.Diameters[index]*itur.u.m ).value
    except Exception as e:
        print("Error AtmosphericAttenuation! ", e)
        exit()

# read all the satellite parameters in the satellite
# >>>>>>>>> WARNING: CHECK THE COUNTING VARIABLE IF YOU UPDATE THE NUMBER OF PARAMETERS!!!!
def readSatelliteFile(files:FILES_struct, sat:SAT_struct) -> SAT_struct:
    
    try:

        counting:int = 14

        with open(files.Sat_file, 'r', encoding='utf-8-sig') as file:
            for line in file:
                if line.lower().__contains__("gain"):
                    sat.Gain = float(line.split("=")[1])
                    counting -= 1
                elif line.lower().__contains__("power"):
                    sat.TX_power = float(line.split("=")[1])
                    counting -= 1
                elif line.lower().__contains__("cable"):
                    sat.TX_cable_loss = float(line.split("=")[1])
                    counting -= 1
                elif line.lower().__contains__("pointing"):
                    sat.Pointing_error = float(line.split("=")[1])
                    counting -= 1
                elif line.lower().__contains__("rate"):
                    sat.Data_rate = float(line.split("=")[1])
                    sat.Data_rate_log = 10*math.log10(sat.Data_rate)
                    counting -= 1
                elif line.lower().__contains__("frequency"):
                    sat.Frequency = float(line.split("=")[1])
                    counting -= 1
                elif line.lower().__contains__("noise"):
                    sat.Noise_temp = 10*math.log10(float(line.split("=")[1]))
                    counting -= 1
                elif line.lower().__contains__("rx"):
                    sat.RX_loss = float(line.split("=")[1])
                    counting -= 1
                elif line.lower().__contains__("extra"):
                    sat.Extra_loss = float(line.split("=")[1])
                    counting -= 1
                elif line.lower().__contains__("ebn0"):
                    sat.EbN0 = float(line.split("=")[1])
                    counting -= 1
                elif line.lower().__contains__("margin"):
                    sat.Margin = float(line.split("=")[1])
                    counting -= 1
                elif line.lower().__contains__("coefficient"):
                    sat.Datarate_coeff = float(line.split("=")[1])
                    counting -= 1
                elif line.lower().__contains__("probability"):
                    sat.Probability = float(line.split("=")[1])
                    counting -= 1
                elif line.lower().__contains__("time"):
                    sat.Time_linkOpening = float(line.split("=")[1])
                    counting -= 1


        if counting > 0:
            print("Error! The Sat.txt parameters are missing something!")
            exit()
            
    except Exception as e:
        print("Error in readSatelliteFile! ", e)
        exit()

    return sat

# read the ground stations information lines
def readStationsFile(files:FILES_struct, gs:Ground_stations_struct) -> Ground_stations_struct:
    
    try:

        with open(files.GS_file, 'r', encoding='utf-8-sig') as file:
            for index,line in enumerate(file):
                line_splitted:str = line.split(";")
                if line_splitted[0] in gs.Names:
                    print(f"Error in readStationsFile: there are two Ground stations in the {files.GS_file} file ({index} row) with the same name!")
                    exit()
                gs.Names.append(line_splitted[0])
                gs.gains.append(float(line_splitted[1]))
                gs.Diameters.append(float(line_splitted[2]))
                gs.lats.append(float(line_splitted[3]))
                if float(line_splitted[4]) < 0:
                    print(f"Error in readStationsFile: the ground station {line_splitted[0]} in line {index} has negative longitude {float(line_splitted[4])}! (must be between 0 and 360)")
                gs.lons.append(float(line_splitted[4]))
                gs.min_elevs.append(float(line_splitted[5]))
                # do not want minimum elevation angle of less than 5deg otherwise itur library will get mad
                if gs.min_elevs[-1] < 5:
                    print(f"Error in readStationsFile! {line_splitted[0]} (row {index}) has a minimum elevation angle <5 deg!")

        gs.Num = len(gs.Names)

    except Exception as e:
        print("Error in readStationsFile! ", e)
        exit()
    
    
    return gs

# taking seconds -> float and creating a string with this format example
# "5 days 12h 0m 0s"
def secondsToDayHourMinuteSeconds_str(seconds:float) -> str:
    days, remainder = divmod(seconds, 86400)
    hours, remainder = divmod(remainder, 3600)
    minutes, sec = divmod(remainder, 60)
    return f"{days:.0f}days {hours:.0f}h {minutes:.0f}m {sec:.0f}s"

# taking seconds -> float and return a list with calculated days, hours, minutes and seconds
def secondsToDays(seconds:float) -> float:
    return seconds/86400

# take bits -> float and create a string with this format example
# 10000 bits
# '10 Kbits (1.25 KB)'
def bitsToString(bits:float) -> str:
    
    ret:str = ""

    if bits > 1e12:
        ret = f"{bits/1e12:.3f} Tbits ({bits/1e12/8:.3f} TB)"
    elif bits > 1e9 and bits <= 1e12:
        ret = f"{bits/1e9:.3f} Gbits ({bits/1e9/8:.3f} GB)"
    elif bits > 1e6 and bits <= 1e9:
        ret = f"{bits/1e6:.3f} Mbits ({bits/1e6/8:.3f} MB)"
    elif bits > 1e3 and bits <= 1e6:
        ret = f"{bits/1e3:.3f} Kbits ({bits/1e3/8:.3f} KB)"
    else:
        ret = f"{bits:.3f} bits ({bits/8:.3f} B)"

    return ret

# calculate the elevation of the satellite respect the ground station in degree
# this must be between 0 and 90 deg
def calculateElevation(an:Analysis_struct, GS_vec:Vector_struct, Sat_vec:Vector_struct) -> float:

    try:

        a:float = an.Distance
        b:float = magnitude(GS_vec)
        c:float = magnitude(Sat_vec)

        A:float = math.degrees(math.acos((b*b + c*c - a*a)/(2*b*c)))
        B:float = math.degrees(math.acos((a*a + c*c - b*b)/(2*a*c)))
        C:float = math.degrees(math.acos((a*a + b*b - c*c)/(2*a*b)))

        return max(A,B,C) - 90

    except Exception as e:
        print("Error in calculateElevation! ", e)
        exit()

# add a row to the dataframe
def addRow(dataframe: pd.DataFrame, row:DataFrameRow_struct) -> pd.DataFrame:

    try:

        row = pd.DataFrame([{ \
            'GS Name': row.GS_Name,\
            'Start': row.Start,\
            'Stop': row.Stop,\
            'Duration [sec]': row.Duration,\
            'Min L.M. [dB]': row.Min_LM,\
            'Max L.M. [dB]': row.Max_LM,\
            'Data [MB]': row.Data \
        }])

        if dataframe.empty:
            return row
        else:
            return pd.concat([dataframe, row], ignore_index=True)

    except Exception as e:
        print("Error in addRow! ", e)
        exit()

# calculate the module of the vector
def magnitude(p:Vector_struct) -> float:
    return math.sqrt(p.X*p.X + p.Y*p.Y + p.Z*p.Z)

# calculate the maximum distance between satellite and ground station
# when the satellite is at the horizon with elevation 0deg
def maxDistance(Re:float, Altitude:float):
    return math.sqrt((Re+Altitude)*(Re+Altitude) - (Re)*(Re))

# calculate the link margin
def calcLinkMargin(sat:SAT_struct, gs:Ground_stations_struct, index:int, an:Analysis_struct) -> float:
    return 228.6 + sat.TX_power + sat.Gain - sat.TX_cable_loss - sat.Pointing_error - an.FSL - an.Atm_loss - sat.Data_rate_log + gs.gains[index] - sat.RX_loss - sat.Noise_temp - sat.EbN0 - sat.Margin - sat.Extra_loss

# update an average float each time
def updateAverage(average:float, tot:int, element:float) -> float:
    return average + (element-average)/(tot+1)

# read first and last line of a file and return them as a list  
def first_and_second_line(file:str) -> list:
    with open(file, 'r', encoding='utf-8-sig') as f:
        first = f.readline().strip()
        for line in f:
            second = line

    return [first, second]

# return a string format from seconds -> float
# example: "0h 5m 32s
def secondsToHoursMinutesSeconds_str(time:float) -> str:
    hours, remainder = divmod(time, 3600)
    minutes, seconds = divmod(remainder, 60)
    return f"{hours:.0f}h {minutes:.0f}m {seconds:.0f}s"


# function for clearing the command line
def clear():
    os.system('cls' if os.name == 'nt' else 'clear')




# ------------------------------------- INITIALIZATION SECTION ---------------------------------




# file struct data
files = FILES_struct()
# satellite struct data
sat = SAT_struct()
# ground stations struct data
gs = Ground_stations_struct()
# output struct data
output = Output_struct()
# satellite and ground station position vectors
P_sat = Vector_struct()
P_gs = Vector_struct()
# analysis struct used to store information
an = Analysis_struct()






# ------------------------------------- ANLYSIS SECTION ---------------------------------------






# variable used for user inputs
command:str = ""

while True:

    command = input("Do you wanna 'load' or 'calc'? ")

    if command.lower() == 'load':
        with open('data.pkl', 'rb') as f:
            files, sat, gs, output, P_sat, P_gs, an, dataframe = pickle.load(f)

    elif command.lower() == 'calc':

        print("Loading parameters...")

        # we take the first and last line on the PosSat.txt file
        first, last = first_and_second_line(files.PosSat_file)
        # first and last date
        first_date = datetime.strptime(" ".join(first.strip().split()[4:]), "%d %b %Y %H:%M:%S.%f")
        last_date = datetime.strptime(" ".join(last.strip().split()[4:]), "%d %b %Y %H:%M:%S.%f")
        # we subtract them and we calculate the amount of seconds that the analysis
        # will last
        output.Tot_analysis_time = (last_date - first_date).total_seconds()

        an.analysis_days = secondsToDays(output.Tot_analysis_time)

        # initialization of the ground stations and satellite parameters
        sat = readSatelliteFile(files, sat)
        gs = readStationsFile(files, gs)

        # check if the ground station numbers are consistent
        with open(files.PosGS_file, 'r') as file:
            line:str = file.readline()
            if len(line.split())/3 != gs.Num:
                print("Error! The number of ground stations in the GS.txt and PosGS.txt are not the same!")
                exit()


        # counting the number of rows 
        Num_rows:int = 0
        with open(files.PosSat_file, 'r') as file:  
            Num_rows = sum(1 for line in file)


        # counter at which line we are of the analysis
        counter:int = 0

        # percentage advancement variables
        percentage:int = 0
        percentage_increment:int = 10


        new_row = DataFrameRow_struct()

        print("Analysis in progress...")

        an.Starting_time = time.time()

        # start the analysis by opening the PosGS.txt and PosSat.txt files
        with open(files.PosGS_file, 'r', encoding='utf-8-sig') as fileGS:
            with open(files.PosSat_file, 'r', encoding='utf-8-sig') as fileSat:
                for line in fileSat:

                    # add 1 to the line counter
                    counter += 1

                    # checking if we need to upgrade the progress 'bar'
                    if (counter/Num_rows)*100 >= percentage:
                        print("working... ", percentage, "%")
                        percentage += percentage_increment

                    # split the line read on PosSat.txt
                    line_split:str = line.split()

                    # get the current position of the satellite
                    P_sat.X = float(line_split[0])
                    P_sat.Y = float(line_split[1])
                    P_sat.Z = float(line_split[2])

                    # get the current altitude of the satellite
                    an.Altitude = float(line_split[3])

                    # if the counter > 1 the old date goes to B and the new one goes to A
                    if counter > 1:
                        an.DateTime_B = an.DateTime_A
                    an.DateTime_A = datetime.strptime(" ".join(line_split[4:]), "%d %b %Y %H:%M:%S.%f")

                    # we calculate the current earth radius respect to the satellite position
                    an.Re = magnitude(P_sat) - an.Altitude

                    # we split the ground station file line
                    line_gs_split:list = fileGS.readline().split()

                    # check if there is a ground station that fulfills the requirements for the communication
                    for kk in range(gs.Num):

                        # position of the kk ground station using the line which is separated as 'X Y Z X Y Z X Y Z ....'
                        #                                                                         0 1 2 3 4 5 6 7 8
                        P_gs.X = float(line_gs_split[0+(3*kk)])
                        P_gs.Y = float(line_gs_split[1+(3*kk)])
                        P_gs.Z = float(line_gs_split[2+(3*kk)])

                        # calculate the distance between the satellite and the kk ground station
                        an.Distance = calcDistance(P_sat, P_gs)

                        # if the distance between the two is less than the maximum one we can also check the elevation
                        # the maximum distance is calculated as the satellite is directly in the horizon with elevation 0deg
                        if an.Distance < maxDistance(an.Re, an.Altitude):

                            # if we are here the distance is correct so we check the minimum elevation of the ground station
                            # calculate it
                            an.Elevation = calculateElevation(an, P_gs, P_sat)

                            # if the elevation is greater than the minimum one and less than 90deg
                            if an.Elevation >= gs.min_elevs[kk] and an.Elevation <= 90:

                                # if the link was not active it means that we are starting a new access
                                if an.Link_active == False:
                                    new_row.Start = str(an.DateTime_A)  # save the starting datetime 
                                    new_row.GS_Name = gs.Names[kk]      # save the name of the ground station 

                                # calculate the free space losses
                                an.FSL = FSL(an.Distance, sat)
                                # calculate the atmospheric losses
                                an.Atm_loss = AtmosphericAttenuation(gs, sat, an.Elevation, kk)

                                # calculate the link margin
                                link_margin:float = calcLinkMargin(sat, gs, kk, an)

                                # save the new overall average link margin
                                output.AVG_link_margin = updateAverage(output.AVG_link_margin, counter, link_margin)

                                # if the link margin is greater than the maximum one for this row we save it
                                if link_margin > new_row.Max_LM:
                                    new_row.Max_LM = link_margin
                                # if the link margin is less than the minimum one for this row we save it
                                if link_margin < new_row.Min_LM:
                                    new_row.Min_LM = link_margin

                                # if the link margin is positive it means we are transmitting
                                if link_margin >= 0:
                                    # if we are not at the start we can perform a subtraction between last and new date
                                    # to know how much time it passed in order to record the time we are in communication mode
                                    if counter != 1:
                                        new_row.Duration += (an.DateTime_A - an.DateTime_B).total_seconds()

                                # if we are here it means the link is active
                                an.Link_active = True
                                # stop the for loop so we don't waste time
                                break

                    # if no ground stations have been found to communicate
                    else:
                        # if the link was active it means the communication has stopped
                        if an.Link_active == True:
                            # we record the stop datatime and we subtract from the total duration
                            # the time for link opening just as a safe margin
                            new_row.Stop = str(an.DateTime_A)
                            new_row.Duration -= sat.Time_linkOpening
                            if new_row.Duration > 0:
                                # we calculate the data rate taking into account the coefficient for 'information' and 'data' rates
                                # we put it in MB just for semplicity
                                new_row.Data = sat.Data_rate*sat.Datarate_coeff*new_row.Duration/8/1e6
                                # we add this new pass to the dataframe
                                dataframe = addRow(dataframe, new_row)
                            # reset the row for the next pass
                            new_row = DataFrameRow_struct() 
                            # the link is not active
                            an.Link_active = False     


        # stopping time for the analysis to know how much time is passed
        an.Ending_time = time.time()

        # transform start and stop datatime string to datatime
        dataframe['Start'] = pd.to_datetime(dataframe['Start'])
        dataframe['Stop'] = pd.to_datetime(dataframe['Stop'])

        # calculating the time that passes between passages
        for kk in range(1,dataframe.shape[0]):
            output.NoAccess_Step.append((dataframe['Start'][kk] - dataframe['Stop'][kk-1]).total_seconds())

        output.Max_time_noAccess = max(output.NoAccess_Step)
        output.AVG_time_noAccess = np.mean(output.NoAccess_Step)

        # filling the output struct data
        output.Min_link_margin = dataframe['Min L.M. [dB]'].min()
        output.Max_link_margin = dataframe['Max L.M. [dB]'].max()
        output.Min_access_time = dataframe['Duration [sec]'].min()
        output.Max_access_time = dataframe['Duration [sec]'].max()
        output.AVG_access_time = dataframe['Duration [sec]'].mean()
        output.Tot_access_time = dataframe['Duration [sec]'].sum()
        output.Average_time_per_day = output.Tot_access_time/an.analysis_days
        output.Tot_contacts = dataframe.shape[0]   
        output.Average_time_per_contact = output.Tot_access_time/output.Tot_contacts
        output.Data_volume_total = sat.Data_rate*sat.Datarate_coeff*output.Tot_access_time
        output.Data_volume_per_day = output.Data_volume_total/an.analysis_days

        for gsName in gs.Names:

            dataframe_filtered = dataframe[dataframe['GS Name'] == gsName]

            output.GS_names.append(gsName)
            output.GS_num_access.append(dataframe_filtered.shape[0])
            output.GS_min_access.append(dataframe_filtered['Duration [sec]'].min())
            output.GS_max_access.append(dataframe_filtered['Duration [sec]'].max())
            output.GS_data_volume.append(dataframe_filtered['Duration [sec]'].sum()*sat.Data_rate*sat.Datarate_coeff)
            output.GS_min_lm.append(dataframe_filtered['Min L.M. [dB]'].min())
            output.GS_max_lm.append(dataframe_filtered['Max L.M. [dB]'].max())

            # saving the data in a file
            with open('data.pkl', 'wb') as f:   
                pickle.dump([files, sat, gs, output, P_sat, P_gs, an, dataframe], f)

            # save the dataframe in a csv file
            dataframe.to_csv(files.Output_file, index=False)








# -------------------------------------- PRINTING SECTION -------------------------------------






    # printing section which is infinite
    while True:

        for i in range(50):
            print("\n")
        # clear the command line
        # only valid if you are not in debug mode and
        # there is a command line window
        clear()

        # printing general parameters
        print("The analysis took:\t\t", secondsToHoursMinutesSeconds_str(an.Ending_time - an.Starting_time))
        print("Total analysis time:\t\t", secondsToDayHourMinuteSeconds_str(output.Tot_analysis_time))
        print("-----------------------------------------------------------------------------------------")
        print(f"Tot access time: \t\t{secondsToDayHourMinuteSeconds_str(output.Tot_access_time)}")
        print(f"Access time per day: \t\t{secondsToHoursMinutesSeconds_str(output.Average_time_per_day)} ({output.Average_time_per_day/60:.1f} min)")
        print(f"Average access time: \t\t{secondsToHoursMinutesSeconds_str(output.Average_time_per_contact)}")
        print(f"Number of access:\t\t{output.Tot_contacts}")
        print(f"Average link margin:\t\t{output.AVG_link_margin:.2f} dB")
        print(f"Max no contact:\t\t\t{secondsToHoursMinutesSeconds_str(output.Max_time_noAccess)}")
        print(f"Average no contact:\t\t{secondsToHoursMinutesSeconds_str(output.AVG_time_noAccess)}")
        print(f"Min link margin:\t\t{output.Min_link_margin:.2f} dB")
        print(f"Max link margin:\t\t{output.Max_link_margin:.2f} dB")
        print(f"Average link margin:\t\t{output.AVG_link_margin:.2f} dB")
        print(f"Total data:\t\t\t{bitsToString(output.Data_volume_total)}")
        print(f"Data per day:\t\t\t{bitsToString(output.Data_volume_per_day)}")
        
        print("-----------------------------------------------------------------------------------------")


        


        combined = zip(output.GS_names, output.GS_num_access, output.GS_min_access, output.GS_max_access, output.GS_data_volume, output.GS_min_lm, output.GS_max_lm)
        # printing the general parameters for each ground station
        for name,num_access,min_access,max_access,data_volume,min_lm,max_lm in combined:
            print()
            print(f"##########   {name}   ##########")
            print(f"Number of access:\t{num_access}")
            print(f"Min access time:\t{min_access:.1f} sec")
            print(f"Max access time:\t{max_access:.1f} sec")
            print(f"Data:\t\t\t{bitsToString(data_volume)}")
            print(f"Min L.M:\t\t{min_lm:.2f}")
            print(f"Max L.M.\t\t{max_lm:.2f}")


        print()
        command = input("Type 'exit', 'all', or ground station name: ")

        # if we want details for one ground station
        if command in gs.Names:
            index = gs.Names.index(command)
            # we eliminate the name column which is useless
            dataframe_filtered = dataframe[dataframe['GS Name'] == command]
            dataframe_filtered = dataframe_filtered.drop('GS Name', axis=1)

            while True:
                # clear
                for i in range(50):
                    print("\n")
                clear()

                # print the dataframe of the specific ground station
                print(dataframe_filtered)                

                command = input("Type 'exit', 'back', 'time', 'dur': ")

                # check the next command
                if command.lower() == 'exit':
                    exit()
                elif command.lower() == 'back':
                    break
                # sort from the farthest to the closest
                elif command.lower() == 'time':
                    dataframe_filtered = dataframe_filtered.sort_values(by="Start")
                # sort from the one that lasts the least to the one that lasts the longest
                elif command.lower() == 'dur':
                    dataframe_filtered = dataframe_filtered.sort_values(by="Duration [sec]")
        # printing all the passages
        elif command.lower() == 'all':
            dataframe_filtered = dataframe
            
            while True:

                for i in range(50):
                    print("\n")
                clear()

                print(dataframe_filtered)

                command = input("Type 'exit', 'back', 'time', 'dur': ")
                if command.lower() == 'exit':
                    exit()
                elif command.lower() == 'back':
                    break
                elif command.lower() == 'time':
                    dataframe_filtered = dataframe_filtered.sort_values(by="Start")
                elif command.lower() == 'dur':
                    dataframe_filtered = dataframe_filtered.sort_values(by="Duration [sec]")

            
        elif command.lower() == 'exit':
            exit()